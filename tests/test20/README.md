## 测试场景-@Computed 装饰器与计算属性缓存

### 测试目的

验证 `@Computed` 装饰器对类的 getter 方法的缓存优化能力和响应式行为，测试其如何提升服务属性计算性能与响应式更新。

### 测试要点

1. **普通 getter 与 @Computed 修饰的对比**
   - 普通 getter 从不缓存计算结果，每次访问都会重新计算
   - 使用 `@Computed` 修饰的 getter 具有缓存能力，当依赖项未变化时不会重新计算
   - 如果依赖项发生变化，`@Computed` 修饰的属性会自动清除缓存并重新计算

2. **与 Vue 的 reactive 结合**
   - 不使用 `reactive` 包装时，`@Computed` 依然可以正常工作
   - 使用 `reactive` 包装后，响应式加强且缓存更智能
   - 测试验证 `@Computed` 在各种场景下都可以保持缓存效果

3. **多个计算属性的交互**
   - 同一服务中定义多个使用 `@Computed` 的计算属性
   - 每个计算属性单独维护其缓存和依赖项
   - 当共同依赖项变化时，所有相关计算属性都会自动更新

4. **多实例性能**
   - 测试多个类实例之间的计算属性缓存是否独立
   - 确认每个实例的缓存机制只影响其自身属性
   - 验证不同实例之间的独立性和无干扰性

5. **带有 setter 的计算属性**
   - 验证 `@Computed` 装饰器对包含 setter 的计算属性的支持
   - 测试 setter 是否能正常工作并触发相关响应式更新
   - 确保 setter 改变依赖项后，缓存能够正确失效并重新计算

这个测试用例展示了 `@Computed` 装饰器如何优化服务中计算属性的性能，通过智能缓存和依赖跟踪减少不必要的重复计算，同时确保在相关依赖发生变化时属性能正确更新。这与 Vue 的 computed 属性功能类似，但应用在了服务类中。
